# 학습 내용 정리

---

## WebSocket vs HTTP

- HTTP 와 마찬가지로 WebSocket 도 유저이다. 
- HTTP 에서는 한번 일련의 요청-응답 작업 이후 유저의 상태를 저장하지 않는다. => stateless
  - 따라서 쿠키 혹은 토큰 방식의 로그인 방식을 취한다.

- WebSocket은 `http://`, `https://` 와 같이 접속하는 것이 아닌 `wss://`, `ws://` 으로 접속한다. 
- 반면, WebSocket의 경우에는 연결이 일어날때 핸드셰이크 과정이 존재한다. 
  - 이러한 연결과정에서 서버는 해당 연결을 수락하거나 거절한다. 이러한 핸드셰이크 과정이 끝나면 연결이 된다.
  - 이렇게 연결과정이 존재하고 연결한 후에는 서버에서 요청을 보낸 쪽을 인식하게된다. 
- 연결되어 있기 떄문에 원한다면 서버가 유저에게 메시지를 보낼 수 있다. 
  - 즉, 서버가 유저에게 메세지를 보낼 수 있다. => request를 기다리지 않아도 된다. 
  - request, reponse 과정을 거치지 않고 유저에게 데이터를 보낼 수 있다. => bidirectional connection
- 이러한 일련의 과정은 연결이 성립되었을 때 일어난다. 
- 유저또한 마찬가지이다.
- 이것이 웹소켓의 사용이유이다. 

- 브라우저에는 빌트인 WebSocket API 가 존재한다.
- 어떤 프로그래밍 언어에 국한되지 않는다. => 프로토콜이기때문에
- WebSocket은 브라우저와 백엔드 사이에만 존재하는 것이 아니다. => ex) 두개의 백엔드 서버에서도 동작한다. => 이것은 http도 마찬가지이다.

--- 

## WS npm package

- 채팅방을 예로두면 WebSocket 프로토콜에 포함되지 않는다. => 단순한 feature 일 뿐이다. 
- 사실 ws를 이용한 framework가 존재한다. 
- 따라서 우리가 다운받아 사용할 WS는 WebSocket의 구현체 즉 코어이고, 개발자들이 WebSocket의 프로토콜에 맞추어 코드로 옮긴 구현체이다.
- 부가적인 유틸리티가 없어 필요한 것은 추가적으로 구현한다.
- ws를 이용해 public 채팅을 만들것이고, ws를 사용하는 framework도 있다.


---

## WebRTC(Web Real Time Communication)

- 소켓을 이용한 채팅은 peer to peer 가 아니였다. 
  - 메세지는 서버로 이동한 후 서버가 모두에게 메세지를 뿌려주는 형태였다. 즉 모두가 서버에 연결되어 있고 서버가 메세지를 전달하는 형태였다. => peer-to-peer 가 아님
- WebRTC의 경우 서버가 아예 필요없는 것은 아니다. Signaling이라고 하는 작업을 통해 서로의 브라우저가 어떤 IP에 어떤 포트로 열려있는지 서로 확인하는 과정을 거친다. => 이때 서버가 필요하다. 이렇게 커넥션이 연결되면 peer-to-peer 통신이 이루어진다. => 따라서 서버는 영상이나 음성을 처리하는 것이 아닌 통신연결만을 지원해주면된다.
- 결과적으로 서버를 사용해 브라우저가 다른 브라우가 어디있는지 알게 해준다.
- 영상, 음성, 텍스트를 전달할 수 있다 => 어? 그러면 텍스트의 경우에 동시편집을 지원할 수 있는것이 아닐까? => 알아보자